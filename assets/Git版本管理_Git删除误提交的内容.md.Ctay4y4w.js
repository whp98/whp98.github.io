import{_ as e,c as s,o as a,ag as t}from"./chunks/framework.DWdSXOaE.js";const g=JSON.parse('{"title":"Git删除误提交的内容","description":"","frontmatter":{},"headers":[],"relativePath":"Git版本管理/Git删除误提交的内容.md","filePath":"Git版本管理/Git删除误提交的内容.md","lastUpdated":1717397989000}'),p={name:"Git版本管理/Git删除误提交的内容.md"};function l(n,i,h,r,o,d){return a(),s("div",null,[...i[0]||(i[0]=[t('<h1 id="git删除误提交的内容" tabindex="-1">Git删除误提交的内容 <a class="header-anchor" href="#git删除误提交的内容" aria-label="Permalink to &quot;Git删除误提交的内容&quot;">​</a></h1><h2 id="报错步骤和解释" tabindex="-1">报错步骤和解释 <a class="header-anchor" href="#报错步骤和解释" aria-label="Permalink to &quot;报错步骤和解释&quot;">​</a></h2><h3 id="step-1-遍历所有历史记录递归删除文件" tabindex="-1">step 1 遍历所有历史记录递归删除文件 <a class="header-anchor" href="#step-1-遍历所有历史记录递归删除文件" aria-label="Permalink to &quot;step 1 遍历所有历史记录递归删除文件&quot;">​</a></h3><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> filter-branch</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --force</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --index-filter</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;git rm -rf --cached --ignore-unmatch filename&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --prune-empty</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --tag-name-filter</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --all</span></span></code></pre></div><p>这个命令的作用是遍历整个提交历史,删除指定的文件,并重写项目历史。</p><p>具体来说:</p><p>--force:强制执行过滤分支操作,即使存在分支冲突也继续执行。</p><p>--index-filter:后面跟要执行的命令,这里是删除指定文件。</p><p>--cached:只从索引中删除,工作树不受影响。</p><p>--ignore-unmatch:忽略不存在于索引中的文件。</p><p>--prune-empty:删除因为文件全部被删除而变空的提交。</p><p>--tag-name-filter:后面跟命令,这里用cat表示保持标签名不变。</p><p>-- --all:针对所有分支进行操作。</p><p>所以这条命令的效果是,在项目完整历史中删除指定的filename文件,并清理由此产生的空提交记录。重写历史后,这个文件就好像从来没有被加入过版本控制一样。</p><p>需要注意的是,这会重写项目全部历史,不要在公共分支上轻易使用,以免对其他人产生影响。</p><h3 id="step-2-删除git的reflog文件" tabindex="-1">step 2 删除Git的reflog文件 <a class="header-anchor" href="#step-2-删除git的reflog文件" aria-label="Permalink to &quot;step 2 删除Git的reflog文件&quot;">​</a></h3><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -rf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .git/refs/original</span></span></code></pre></div><p>这个命令用于删除 Git 的 reflog,即删除 .git/refs/original 目录。</p><p>reflog 在 Git 中用于记录分支提交历史的引用日志,它可以让你在丢失提交的情况下找回数据,是 Git 的一个重要的恢复机制。</p><p>但是有时为了某些目的,比如去除项目中不想保留的敏感信息,需要删除 reflog。</p><p>rm -rf .git/refs/original 这个命令就是用来删除整个 reflog 的。</p><p>删除后,你就无法通过 reflog 恢复到之前的状态了。所以在执行这个命令前,一定要慎重考虑,确认真的不需要保留 reflog。</p><p>另外,要完全删除历史信息,除了删 reflog 外,还需要使用 git filter-branch 等命令来重写提交记录。</p><p>所以 rm -rf .git/refs/original 只是删除 reflog 的一步,还需要其他操作来完全抹去项目的历史记录。这需要谨慎对待。</p><h3 id="step-3-立即清除git的引用日志-reflog" tabindex="-1">step 3 立即清除Git的引用日志(reflog) <a class="header-anchor" href="#step-3-立即清除git的引用日志-reflog" aria-label="Permalink to &quot;step 3 立即清除Git的引用日志(reflog)&quot;">​</a></h3><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reflog</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> expire</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --expire=now</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --all</span></span></code></pre></div><p>这个命令的作用是立即清除 Git 的引用日志(reflog)。</p><p>git reflog expire 用于管理引用日志的过期时间,默认保存90天。</p><p>--expire=now 参数表示立即设置全部引用日志的过期时间为现在,即清空所有的引用日志。</p><p>--all 参数表示不仅清理本地分支的reflog,还清理远程跟踪分支的reflog。</p><p>总之,git reflog expire --expire=now --all 将立即清除所有本地分支和远程跟踪分支的引用日志,无法通过引用日志恢复提交记录。</p><p>需要注意的是:</p><ol><li><p>这只是删除引用日志,不影响实际的提交记录,如果想要完全重写历史,还需要配合filter-branch等命令。</p></li><li><p>如果已推送到远程仓库,其他人仍可能有备份保留引用日志,所以无法从服务器端完全清除引用日志。</p></li><li><p>删除引用日志会使某些Git操作更难恢复,如重置到以前的提交。</p></li></ol><p>所以这个命令要慎重使用,确实需要清除引用日志时再执行。</p><h3 id="step4-立即进行git垃圾回收和优化" tabindex="-1">step4 立即进行Git垃圾回收和优化 <a class="header-anchor" href="#step4-立即进行git垃圾回收和优化" aria-label="Permalink to &quot;step4 立即进行Git垃圾回收和优化&quot;">​</a></h3><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --prune=now</span></span></code></pre></div><p><code>git gc --prune=now</code> 命令的作用是立即进行 Git 垃圾回收和优化。</p><p><code>git gc</code> 命令表示运行 Git 垃圾回收进程,它会做两件事:</p><ol><li><p>压缩 Git 数据库 - 将松散的对象打包成单个文件,使仓库变小。</p></li><li><p>删除不可达对象 - 删除所有不属于任何提交的commit对象及相关文件。</p></li></ol><p><code>--prune=now</code> 选项强制立即进行第二步删除不可达对象的操作,默认 gc 会延迟一段时间才会删除。</p><p>这样做的目的是防止删除仍在使用的对象。但是 <code>--prune=now</code> 会跳过等待时间,强制立即删除。</p><p>总结:</p><ul><li><code>git gc</code> - 执行 Git 垃圾回收与优化</li><li><code>--prune=now</code> - 强制立即删除不可达对象</li></ul><p>这个命令可以减少仓库的磁盘用量。但要注意它会删除对象,这样可能影响到 Git 的正常使用或丢失一些历史,所以需要谨慎使用。</p><h3 id="step5-强制推送当前分支到远程仓库-并覆盖远程仓库的改动" tabindex="-1">step5 强制推送当前分支到远程仓库,并覆盖远程仓库的改动 <a class="header-anchor" href="#step5-强制推送当前分支到远程仓库-并覆盖远程仓库的改动" aria-label="Permalink to &quot;step5 强制推送当前分支到远程仓库,并覆盖远程仓库的改动&quot;">​</a></h3><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --force</span></span></code></pre></div><p><code>git push --force</code> 命令的作用是强制推送当前分支到远程仓库,并覆盖远程仓库的改动。</p><p>常规的 <code>git push</code> 如果远程仓库存在新提交,会被拒绝,必须先拉取远程更新后再推送。</p><p>但是 <code>git push --force</code> 会无视这种情况,直接推送本地版本覆盖远程,使远程仓库匹配本地仓库。</p><p>使用时需要注意:</p><ul><li>这会使远程仓库的提交历史被重写,其他人的提交可能会丢失</li><li>一旦推送,之前的提交记录无法恢复</li><li>不应该在共享使用的分支上使用,这会使其他人的工作受到破坏</li></ul><p>只有在符合下面条件时才可以安全使用 <code>--force</code>:</p><ul><li>可以确定不会覆盖其他人的工作</li><li>推送一个新的分支或标签</li><li>修复本地错误的提交</li></ul><p>在公共分支上,应避免使用 <code>--force</code>,以免对他人造成破坏。需要强制推送时,也应先告知团队成员。</p>',54)])])}const k=e(p,[["render",l]]);export{g as __pageData,k as default};
