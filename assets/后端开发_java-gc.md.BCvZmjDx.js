import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.8SQNO8WI.js";const g=JSON.parse('{"title":"垃圾回收机制","description":"","frontmatter":{"title":"垃圾回收机制","tags":["垃圾回收","gc"],"categories":["垃圾回收"],"abbrlink":"6306","date":"2020-05-10T16:17:48.000Z"},"headers":[],"relativePath":"后端开发/java-gc.md","filePath":"后端开发/java-gc.md","lastUpdated":1726751071000}'),h={name:"后端开发/java-gc.md"};function t(p,s,k,e,r,E){return n(),a("div",null,[...s[0]||(s[0]=[l(`<h1 id="垃圾回收机制" tabindex="-1">垃圾回收机制 <a class="header-anchor" href="#垃圾回收机制" aria-label="Permalink to &quot;垃圾回收机制&quot;">​</a></h1><p>使用Java多了，只会new但是还没仔细研究过Java的垃圾回收，这篇文章，就是浅谈java和其他语言（C++）的垃圾回收。 严格来说程序是需要自己管理内存的，但是Java的jvm帮我们做了这些，这个也是Java和C++的最大不同，C++中所有的内存必须 回收如果没有回收那么就是内存泄露了，Java并不是这样，Java在内存充足的时候不会进行垃圾回收，而随着程序的运行结束，Java所占用 资源也会全部释放给操作系统，整个程序运行中也不会进行垃圾回收。</p><p>C++中有一个用于垃圾回收的析构函数，C++销毁对象的时候必须使用析构函数，这个可以用来做一些工作，这个意味着对象被放弃的时候一定会使用到，但是Java中即使你将对象置为null，也不一定会使jvm进行垃圾回收。Java中的finalize()就是用于在垃圾回收的时刻进行清理工作的，这个方法调用之后并不会导致内存被立即释放，下一次垃圾回收的时候这个对象才真正的被释放。</p><p>下面是一个例子，当内存被占用的时候finalize函数被调用了（也可以使用system.gc()来强制垃圾回收），但是如果程序没有将内存占满，那么函数不会被调用。C++中使用delete来操作某个对象析构函数一定会被调用。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TestFinalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    TestFinalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> l</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //占用内存</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    protected</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> finalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Throwable {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;   执行finalized&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">finalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        TestFinalize testFinalize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TestFinalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        testFinalize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //不断创建String对象来占用内存</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            String s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">* 输出 0   执行finalized</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">*/</span></span></code></pre></div><p>垃圾回收只和内存有关，上面的测试代码并不合格，因为finalize这个函数体中的主要内容不是内存回收，不过这里要特别注意一点， 无论一个对象中是否含有其他对象都不用在finalize中指定内存回收行为，垃圾回收会释放对象占用的全部内存，finalize只有一种特殊的用途。</p><p>就是本地方法的特例，本地方法就是使用其他语言（C/C++或者其他）创建的方法，这些方法中可能会分配内存，然后这些内存必须释放，否则会导致内存泄露。而在finalize中调用类似c语言中的free函数是保证程序稳定运行的关键。</p><h2 id="终结条件的应用" tabindex="-1">终结条件的应用 <a class="header-anchor" href="#终结条件的应用" aria-label="Permalink to &quot;终结条件的应用&quot;">​</a></h2><p>由于finalize并不一定会被使用，所以这个方法并不是常用的,也是比较不推荐使用的，但是有一个场景下这个还是有点用的，那就是终结条件的验证，也就是对象被清理的时候要求一定要怎样，但是对象不被清理的时候没必要验证，比如要求对象清理之前必须存入数据库中，如果有这个要求，可以加一个判断，这个可以检测系统有没有缺陷，这时候可以主动调用system.gc()来强制jvm进行垃圾回收，也可在以后的系统运行中排查出这种故障。</p><h2 id="垃圾回收器的几种工作方式" tabindex="-1">垃圾回收器的几种工作方式 <a class="header-anchor" href="#垃圾回收器的几种工作方式" aria-label="Permalink to &quot;垃圾回收器的几种工作方式&quot;">​</a></h2><p>C++语言的内存管理模式像是一个空间有限的广场，广场上的每一个人都管理自己，而且为了提高空间利用率一般人做完了事情求要离开广场，新来的人就要占领他的位置，Java的内存管理类似于流水线，分配一个对象就前面移动一格（只是比喻，实际上中间夹杂着gc重新排列对象），当资源耗尽的时候释放内存并将剩下的对象集中排列在一起（GC作用）。</p><h3 id="垃圾回收的引用计数机制" tabindex="-1">垃圾回收的引用计数机制 <a class="header-anchor" href="#垃圾回收的引用计数机制" aria-label="Permalink to &quot;垃圾回收的引用计数机制&quot;">​</a></h3><p>引用计数是这样的一种机制就是每个对象会有一个计数器，当有引用连接到对象，计数加一，引用置为null计数减一，然后垃圾回收就遍历所有对象，释放引用计数的为0的对象的内存。不过这个有个互相引用的问题，会极大影响效率。目前这种机制应该没有应用到jvm中。</p><h3 id="一种更快的模式是基于活得对象机制的" tabindex="-1">一种更快的模式是基于活得对象机制的 <a class="header-anchor" href="#一种更快的模式是基于活得对象机制的" aria-label="Permalink to &quot;一种更快的模式是基于活得对象机制的&quot;">​</a></h3><p>如果对象是活得，那么一定会有一个可以被访问的引用链条，那么从堆栈和静态区遍历所有引用直到找到对应的对象，遍历完成之后就可以开始清理那些没有引用的对象，这个也解决了交互自引用的对象组问题。</p><p>这种模式下，java虚拟机采用一种自适应的垃圾回收技术，至于如何找到存活的对象取决于不同的jvm实现，这个也是自适应的垃圾回收的一部分，jvm主要有几种工作模式下面简单介绍一下这几种方式。</p><h2 id="jvm-gc实现" tabindex="-1">jvm gc实现 <a class="header-anchor" href="#jvm-gc实现" aria-label="Permalink to &quot;jvm gc实现&quot;">​</a></h2><h3 id="实现一-停止-复制" tabindex="-1">实现一：停止-复制 <a class="header-anchor" href="#实现一-停止-复制" aria-label="Permalink to &quot;实现一：停止-复制&quot;">​</a></h3><p>这个方式是先暂停程序然后将当前的堆转移到另一个堆，剩下的全是垃圾，这个过程中需要重新映射内存地址，这个方式有两个缺点：在两个堆之间来回倒腾，这将需要原来占用内存的两倍，然后的问题是，当程序运行起来之后，有很多东西是不变的，也就是程序只有一部分需要清理，一部分不需要清理，但是复制，是不会考虑到这些的，这将会导致很大的浪费，这时候垃圾回收器的作用将会体现出自适应的优越性，它从原来的模式转化为另一种机制：标记-清扫模式。</p><h3 id="实现二-标记-清扫" tabindex="-1">实现二：标记-清扫 <a class="header-anchor" href="#实现二-标记-清扫" aria-label="Permalink to &quot;实现二：标记-清扫&quot;">​</a></h3>`,20)])])}const y=i(h,[["render",t]]);export{g as __pageData,y as default};
