import{_ as e,c as l,o as r,ag as i}from"./chunks/framework.DWdSXOaE.js";const u=JSON.parse('{"title":"MVC软件架构模式","description":"","frontmatter":{},"headers":[],"relativePath":"后端开发/j2ee/mvc-arch.md","filePath":"后端开发/j2ee/mvc-arch.md","lastUpdated":1726751071000}'),t={name:"后端开发/j2ee/mvc-arch.md"};function o(h,a,c,n,d,s){return r(),l("div",null,[...a[0]||(a[0]=[i('<h1 id="mvc软件架构模式" tabindex="-1">MVC软件架构模式 <a class="header-anchor" href="#mvc软件架构模式" aria-label="Permalink to &quot;MVC软件架构模式&quot;">​</a></h1><h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h2><p>MVC是一种开发模式，这个模式将应用开发分为三层，M就是Model数据封装负责业务数据的封装，V （View）是指数据展示，C （Controller）则是业务处理控制。这个编程模型提倡将应用程序按照数据封装，展示和处理进行分层，这样的开发模式可以减少开发的工作量，比如说要修改数据展示的形式可以直接修改View层而不用修改M和C就减少了工作量同时程序也显得更加清晰。</p><h2 id="实际应用" tabindex="-1">实际应用 <a class="header-anchor" href="#实际应用" aria-label="Permalink to &quot;实际应用&quot;">​</a></h2><p>公司里面开发其实一般都会采用MVC而且会分的更加细致，比如分成下面几种：</p><ul><li>Service(业务接口) <ul><li>impl （业务实现）</li></ul></li><li>DAO（数据库访问接口）</li><li>VO （发送给前台数据包装类）</li><li>DTO （接受前台数据的包装类）</li><li>Controller （控制层用于REST接口定义并调用业务层接口）</li></ul><p>在java中分层一般用包的形式来表示，这些包围位置一般不同的项目或公司有自己的规定，但是只要能理解这些分层的含义是啥就行。</p><h2 id="为啥要使用mvc呢" tabindex="-1">为啥要使用MVC呢 <a class="header-anchor" href="#为啥要使用mvc呢" aria-label="Permalink to &quot;为啥要使用MVC呢&quot;">​</a></h2><p>MVC就是为了简化开发而设计的软件架构模式，使用这种架构有以下优点：</p><ul><li>便于程序修改</li><li>可以重复利用</li><li>程序的结构直观</li><li>可以单独测试</li></ul><h3 id="便于程序修改" tabindex="-1">便于程序修改 <a class="header-anchor" href="#便于程序修改" aria-label="Permalink to &quot;便于程序修改&quot;">​</a></h3><p>程序被分层实现情况下，如果业务变更了我们可能只需要修改Service的现实不需要考虑前端展示的代码，改起来很快，并不需要了解整个代码的实现逻辑。如果是大杂烩的程序那么如果想要修改恐怕需要看整个功能的显示逻辑。</p><h2 id="可以重复利用" tabindex="-1">可以重复利用 <a class="header-anchor" href="#可以重复利用" aria-label="Permalink to &quot;可以重复利用&quot;">​</a></h2><p>程序的后台业务改了，但是我们不需要重写一个前台，如果保持基本入参和出参的一致，我们直接将服务指向新的服务接口，而无需重写其他代码。</p><h2 id="程序的结构直观" tabindex="-1">程序的结构直观 <a class="header-anchor" href="#程序的结构直观" aria-label="Permalink to &quot;程序的结构直观&quot;">​</a></h2><p>采用分层结构的程序我们能立即找到程序具体功能的实现代码，而不是在一堆大杂烩中提取。 比如想改REST定义，你直接找到Controller包就将代码找到了，节省了很多时间。</p><h2 id="可以独立测试" tabindex="-1">可以独立测试 <a class="header-anchor" href="#可以独立测试" aria-label="Permalink to &quot;可以独立测试&quot;">​</a></h2><p>由于功能的实现的独立的，因此可以对各个层进行单元测试，如果代码耦合在一起就不能单独测试，只能进行功能测试。</p>',18)])])}const m=e(t,[["render",o]]);export{u as __pageData,m as default};
