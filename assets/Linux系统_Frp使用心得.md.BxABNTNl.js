import{_ as s,c as n,o as p,ag as e}from"./chunks/framework.DWdSXOaE.js";const u=JSON.parse('{"title":"Frp使用心得","description":"","frontmatter":{},"headers":[],"relativePath":"Linux系统/Frp使用心得.md","filePath":"Linux系统/Frp使用心得.md","lastUpdated":1717397989000}'),l={name:"Linux系统/Frp使用心得.md"};function t(i,a,c,o,r,h){return p(),n("div",null,[...a[0]||(a[0]=[e(`<h1 id="frp使用心得" tabindex="-1">Frp使用心得 <a class="header-anchor" href="#frp使用心得" aria-label="Permalink to &quot;Frp使用心得&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>最近因为工作需要，使用frp作为内网穿透工具进行windows远程桌面连接。 期间遇到不少问题，采用了不少方法调优，于是写下此文总结下。</p><h2 id="环境介绍" tabindex="-1">环境介绍 <a class="header-anchor" href="#环境介绍" aria-label="Permalink to &quot;环境介绍&quot;">​</a></h2><p>我的服务器是腾讯云轻量香港。系统是Ubuntu 20.04</p><p>Frp 版本用了 0.44.0</p><h2 id="_1-kcp使用" tabindex="-1">1.KCP使用 <a class="header-anchor" href="#_1-kcp使用" aria-label="Permalink to &quot;1.KCP使用&quot;">​</a></h2><p>我之前使用的是TCP，用的不多没感觉有问题，但是我最近不知道是不是网络不好，经常断开。于是使用KCP来尝试优化。</p><p>启用KCP之后我发现效果并不是那么好。经常内部错误还长时间无法恢复，很坑。</p><p>这个有个特点是确实感受到延迟的降低。</p><p>期间还用了三方的花生壳和神着互联左临时替代。其实三方其实也挺好了的比较稳定。</p><h2 id="_2-stcp使用" tabindex="-1">2.STCP使用 <a class="header-anchor" href="#_2-stcp使用" aria-label="Permalink to &quot;2.STCP使用&quot;">​</a></h2><p>STCP是被控端和使用端都安装一个frpc由FRP来为隧道进行实现，这个方案比之前的直连香港要稳定，但是实际体验还是有长时间断链并且无法恢复的情况发生。</p><h2 id="_3-xtcp使用" tabindex="-1">3.XTCP使用 <a class="header-anchor" href="#_3-xtcp使用" aria-label="Permalink to &quot;3.XTCP使用&quot;">​</a></h2><p>这个是打洞，可惜失败了。</p><h2 id="_4-stcp加代理" tabindex="-1">4.STCP加代理 <a class="header-anchor" href="#_4-stcp加代理" aria-label="Permalink to &quot;4.STCP加代理&quot;">​</a></h2><p>这个是我目前使用的方案，可能frp本身通信能力有问题，我用将使用端配置上了http代理，当然代理实现是v2实现的，相当于</p><p>frpc(控制端) -&gt; v2隧道 -&gt; frps -&gt; frpc(被控端)</p><p>这个方案有很厉害的地方</p><ol><li>比较稳定</li><li>可以把带宽拉上去（直接远程看视频也可）</li><li>偶尔卡顿（原先是有的直接跳重连，现在大多情况卡几秒就恢复了）</li></ol><h2 id="_5-多实例-ha负载均衡" tabindex="-1">5.多实例+HA负载均衡 <a class="header-anchor" href="#_5-多实例-ha负载均衡" aria-label="Permalink to &quot;5.多实例+HA负载均衡&quot;">​</a></h2><p>这个方案比较暴力</p><p>在被控机上开四个frpc配置好不同的服务端口，服务器开启四个frps端口和客户端对应。</p><p>控制端开启四个frpc配置好stcp协议，然后使用haproxy配置文件弄好本地四个端口的rdp。</p><p>使用的时候就使用haproxy提供的端口即可，每次断开连接，ha会自动切换端口，能快速恢复服务。</p><p>我的haproxy配置文件可以参考下。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#logging options</span></span>
<span class="line"><span>global</span></span>
<span class="line"><span>    log 127.0.0.1 local0 info</span></span>
<span class="line"><span>    maxconn 1500</span></span>
<span class="line"><span>    quiet</span></span>
<span class="line"><span>    nbproc 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>defaults</span></span>
<span class="line"><span>    log global</span></span>
<span class="line"><span>    #使用4层代理模式，”mode http”为7层代理模式</span></span>
<span class="line"><span>    mode tcp</span></span>
<span class="line"><span>    #if you set mode to tcp,then you nust change tcplog into httplog</span></span>
<span class="line"><span>    option tcplog</span></span>
<span class="line"><span>    option dontlognull</span></span>
<span class="line"><span>    retries 3</span></span>
<span class="line"><span>    option redispatch</span></span>
<span class="line"><span>    maxconn 2000</span></span>
<span class="line"><span>    timeout connect 10s</span></span>
<span class="line"><span>     ##客户端空闲超时时间为 60秒 则HA 发起重连机制</span></span>
<span class="line"><span>    timeout client 10s</span></span>
<span class="line"><span>     ##服务器端链接超时时间为 15秒 则HA 发起重连机制</span></span>
<span class="line"><span>    timeout server 10s </span></span>
<span class="line"><span>#front-end IP for consumers and producters</span></span>
<span class="line"><span></span></span>
<span class="line"><span>listen RDP</span></span>
<span class="line"><span>    bind 127.0.0.1:32000</span></span>
<span class="line"><span>    #配置TCP模式</span></span>
<span class="line"><span>    mode tcp</span></span>
<span class="line"><span>    tcp-request inspect-delay 5s</span></span>
<span class="line"><span>    tcp-request content accept if RDP_COOKIE</span></span>
<span class="line"><span>    persist rdp-cookie</span></span>
<span class="line"><span>    balance leastconn</span></span>
<span class="line"><span>    option tcpka</span></span>
<span class="line"><span>    option tcplog</span></span>
<span class="line"><span>    server one45671	127.0.0.1:45671 check inter 1000 rise 2 fall 2</span></span>
<span class="line"><span>    server one45672	127.0.0.1:45672 check inter 1000 rise 2 fall 2</span></span>
<span class="line"><span>    server one45673	127.0.0.1:45673 check inter 5000 rise 2 fall 2</span></span>
<span class="line"><span>    server one45674	127.0.0.1:45674 check inter 5000 rise 2 fall 2</span></span>
<span class="line"><span>    option redispatch</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>#配置haproxy web监控，查看统计信息</span></span>
<span class="line"><span>listen stats</span></span>
<span class="line"><span>    bind 127.0.0.1:8990</span></span>
<span class="line"><span>    mode http</span></span>
<span class="line"><span>    option httplog</span></span>
<span class="line"><span>    stats enable</span></span>
<span class="line"><span>    #设置haproxy监控地址为http://localhost:8990/frp-stats</span></span>
<span class="line"><span>    stats uri /frp-stats</span></span>
<span class="line"><span>    stats refresh 200ms</span></span></code></pre></div><p>使用可以打开 <code>http://localhost:8990/frp-stats</code> 查看服务状态。</p><p>本地使用 127.0.0.1:32000 连接即可</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>以上就是我目前的体会和经验 要是frp有升级我再尝试优化</p>`,31)])])}const f=s(l,[["render",t]]);export{u as __pageData,f as default};
