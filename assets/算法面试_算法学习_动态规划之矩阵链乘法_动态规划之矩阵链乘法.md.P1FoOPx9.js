import{_ as s,c as e,o as t,ag as p}from"./chunks/framework.8SQNO8WI.js";const i="/assets/2020-02-19-18-52-19.LelE-b9a.jpg",n="/assets/2020-02-19-18-52-57.CKsvgihD.jpg",l="/assets/2020-02-19-18-54-38.BSK31F2-.jpg",g=JSON.parse('{"title":"动态规划之矩阵链乘法","description":"","frontmatter":{"title":"动态规划之矩阵链乘法","abbrlink":"8f42","date":"2019-11-26T19:16:51.000Z","tags":["算法","动态规划","矩阵链乘"],"categories":[["算法","动态规划"]]},"headers":[],"relativePath":"算法面试/算法学习/动态规划之矩阵链乘法/动态规划之矩阵链乘法.md","filePath":"算法面试/算法学习/动态规划之矩阵链乘法/动态规划之矩阵链乘法.md","lastUpdated":1717397989000}'),o={name:"算法面试/算法学习/动态规划之矩阵链乘法/动态规划之矩阵链乘法.md"};function r(c,a,d,h,_,u){return t(),e("div",null,[...a[0]||(a[0]=[p(`<h1 id="动态规划之矩阵链乘法" tabindex="-1">动态规划之矩阵链乘法 <a class="header-anchor" href="#动态规划之矩阵链乘法" aria-label="Permalink to &quot;动态规划之矩阵链乘法&quot;">​</a></h1><p>这个算法的主要目标是降低矩阵连乘的时候的计算量，首先我们可以看一个例子：<br> 现有三个矩阵A，B，C 需要计算A<em>B</em>C 目前已知各个矩阵维数如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A: 10x5  </span></span>
<span class="line"><span>B: 5x200  </span></span>
<span class="line"><span>C: 200x30</span></span></code></pre></div><p>如果采用顺序计算方式即如下算法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(A*B)*C</span></span></code></pre></div><p>那么计算量是<code>10*5*200 + 10*200*30</code> = 70000</p><p>如果计算顺序如下</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A*(B*C)</span></span></code></pre></div><p>那么计算结果是<code>5*200*30 + 10*5*30</code> = 31500</p><p>可以看出来通过在算式中加括号来改变计算顺序可以极大的降低计算量，上面的例子中我们通过改变计算顺序就降低了一半多的计算量。<br> 这时候我们可以知道加括号有用那么我们如何加入括号，如果使用暴力算法求解在各个位置加入括号的效果然后加入括号是否可行呢，那么我们来试试看</p><p>比如我们需要计算两个矩阵相乘的时候可以有一种乘法方案，但是一旦超过2那么我们就面临着一个指数级别的排列组合问题(n<sup>2</sup>)，从这里我们就可以知道穷举法根本不适合解决此问题,因为我们不但要找出所有排列组合还要对没种组合求解，计算量和复杂度都比较超标。<br> 好在我们有比较高明的动态规划算法来解决此类问题</p><h2 id="如何使用动态规划来解决此类问题呢" tabindex="-1">如何使用动态规划来解决此类问题呢 <a class="header-anchor" href="#如何使用动态规划来解决此类问题呢" aria-label="Permalink to &quot;如何使用动态规划来解决此类问题呢&quot;">​</a></h2><p>动态优化问题,注重研究如何让利用额外的内存空间，来存储那些可能会产生重复的计算结果，然后在每次计算中会直接使用已经计算出来的结果，不做重复的计算步骤</p><h2 id="通过动态规划算法来得到矩阵链乘的最优括号化结果" tabindex="-1">通过动态规划算法来得到矩阵链乘的最优括号化结果 <a class="header-anchor" href="#通过动态规划算法来得到矩阵链乘的最优括号化结果" aria-label="Permalink to &quot;通过动态规划算法来得到矩阵链乘的最优括号化结果&quot;">​</a></h2><p>下面通过一个矩阵链乘的最优括号化的问题的实例计算来说明一下：</p><ol><li>对维数为序列&lt;5, 10, 3, 12, 5, 50, 6&gt;的各矩阵，找出其矩阵链乘积的一个最优加全部括号。</li></ol><h3 id="计算步骤" tabindex="-1">计算步骤 <a class="header-anchor" href="#计算步骤" aria-label="Permalink to &quot;计算步骤&quot;">​</a></h3><p>根据公式分别计算m表和s表并且记录下来 <img src="`+i+'" alt=""></p><p><img src="'+n+'" alt=""></p><h3 id="根据s表得出结果" tabindex="-1">根据s表得出结果 <a class="header-anchor" href="#根据s表得出结果" aria-label="Permalink to &quot;根据s表得出结果&quot;">​</a></h3><p><img src="'+l+'" alt=""></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>从上面的实例计算可以分析出可以用动态规划解决的问题的类型，是有大量重复的计算的步骤。通过保存这些需要反复计算的内容，可以减少进一步计算的计算量这就是动态规划问题的特点，我们需要抓住该类问题的特点进行处理。</p>',23)])])}const m=s(o,[["render",r]]);export{g as __pageData,m as default};
