# 存储10亿密码rockyou2024

本文将介绍如何使用Mysql技术存储10亿密码。

## 1. 准备工作`rockyou2024.txt`
https://github.com/hkphh/rockyou2024.txt


## 2.文件拆分
```shell
split -b 100m rockyou2024.txt pass.sp.
```

## 3. 创建数据库表
数据表
```sql
CREATE TABLE pass_dict_n
(
    i_id   INT          NOT NULL AUTO_INCREMENT COMMENT '主键',
    c_pass VARCHAR(100) NOT NULL COMMENT '密码',
    PRIMARY KEY (i_id),
    INDEX idx_c_pass (c_pass)
        COMMENT '密码表'

) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4,
  ROW_FORMAT = Compressed;
```
元数据存储
```sql
create table pass_dict_meta
(
    i_id         int          not null auto_increment comment '主键',
    c_file_name  varchar(100) not null comment '文件名',
    c_table_name varchar(100) not null comment '表名',
    c_table_num varchar(100) not null comment '表名',
    i_file_size  int          not null comment '文件大小',
    i_file_line  int          not null comment '文件行数',
    primary key (i_id),
    index idx_pass_dict_meta (c_file_name)
        comment '密码表元数据'
) engine = innodb
  default charset = utf8mb4
  row_format = compressed;
```
## 4. 解析清理批量导入数据
```java
                try {
                    passwordList = Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8);
                    passwordList = passwordList.stream()
                            .filter(Objects::nonNull).map(String::trim)
                            .filter(s -> !s.isEmpty())
                            .filter(s -> s.length() < 100)
                            .collect(Collectors.toList());
                    List<List<String>> pageList = PageUtils.page(passwordList, batchSize);
                    for (List<String> page : pageList) {
                        passwordMapper.insert(String.valueOf(i), page);
                        log.info("num:{} page:{}", i, page.size());
                    }
                    //插入元数据
                    PassMeta item = new PassMeta();
                    item.setCfilename(fileName);
                    item.setCtablename("pass_dict_" + i);
                    item.setCtablenum(String.valueOf(i));
                    item.setIfileline(passwordList.size());
                    item.setIfilesize((int) new File(filePath).length());
                    passwordMapper.deleteMeta(item);
                    passwordMapper.insertMeta(item);
                } catch (IOException e) {
                    log.error("读取文件失败:{}", e.getMessage());
                }
```

# 5.数据质量评价
1.数据质量很差，乱码数据有不少。

2.很多密码都是乱码级别，没有价值

3.密码长度过长的太多，增加过滤条件 length < 20 之后数据大批量基本就没了

# 6.实现一个密码泄漏检测
```java
 @Test
    public void tryFindPass() {
        String passStr = "";
        List<String> res = new ArrayList<>();
        List<PassMeta> metaList = passwordMapper.getMetaList();
        for (PassMeta p : metaList) {
            res.addAll(passwordMapper.getPasswordList(p.getCtablenum(), passStr));
        }
        if (!res.isEmpty()) {
            log.error("密码已经泄漏");
            System.out.println(res);
        } else {
            log.info("密码没有泄漏!");
        }
    }
```