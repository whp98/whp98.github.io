# 多线程
## 进程
打开Windows任务管理器可以看到的列表就是进程列表，每一个程序至少会启动一个进程。
进程和进程之间的内存是独立的，不会共享内存。
进程和进程之间内存独立，可以提高稳定性和安全行。

## 线程
一个线程是一个进程中的执行场景，每个进程可以开启多个线程。
下载软件中多个下载任务同时进行，但是可以看到下载软件进程并没有创建出和下载数目相同的进程。
这时候下载软件内的软件就是多线程进行的。
执行期间CPU并不是同时执行，而是进行快速的在线程之间切换，这个就是CPU时分复用。
多线程代码的主要作用就是提高CPU的使用率。
多线程减少了CPU空闲的时间，并不是增加了程序执行的速度。
对于比较耗时的任务开启多线程可以减少CPU等待的时间。可以让CPU去执行不在等待的代码。

多线程场景：同时下载N个文件。和N个人同时开视频会议。等。

## 并行和并发
并行是两个任务同一时刻都在执行，需要CPU有多核支持。
并发是指两个或以上任务在同一时间段内同时发生，CPU在这一段时间内在多个任务之间切换，看上去似乎是两个任务都在执行了。

## 多线程的的缺点
1. 设计比较复杂，共享堆内存和芳芳去，多个线程同时执行的时候数据共享处理等处理步骤比较复杂
2. 增加资源消耗，多线程栈内存是不会共享的，开启多线程会有更多的资源消耗
3. 多线程的开启需要有平衡点，并不是线程被越多越好，线程数量超过了本应设计的数量反而会让程序效率下降。(超过了机器本身的极限)

## 使用Java创建线程
在Java中创建线程有3中方式。
### 继承Thread类
```java
/**
 * 1.创建类，继承java.lang.Thread
 * 2.重写run方法,将要在线程中执行的代码写在run中
 * 3.创建自定义类的对象
 * 4.调用start方法开启线程
 */
public class ThreadTest01 {
    public static void main(String[] args) throws InterruptedException {
        /*创建线程对象*/
        MyThread01 myThread01 = new MyThread01();
        /*启动线程*/
        myThread01.start();
        for (int i = 0; i < 1000; i++) {
            System.out.print("nihao ");
        }
    }
}
class MyThread01 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.print("hello ");
        }
        System.out.println();
    }
}
```
### 实现Runnable接口
```java
/**
 * 利用Runnable接口开启多线程
 * 1.自定义类实现java.lang.Runnable
 * 2.覆盖run方法，将多线程代码写在方法内
 * 3.创建Thread对象并将自定义类的对象作为构造函数的方法
 * 4.调用Thread对象的start方法开启线程
 */
public class ThreadTest02 {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyThread02());
        thread.start();
        for (int i = 0; i < 1000; i++) {
            System.out.println("mainThread");
        }
    }
}

class MyThread02 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("myThread");
        }
    }
}
```
### 显示Callable接口
```java
import java.util.concurrent.*;

/**
 * 实现Callable来开启多线程
 * 1.实现Callable接口
 * 2.重写Call方法,将多线程代码写在方法中
 * 3.创建ExecutorService线程池
 * 4.将自定义类的对象放入线程池
 * 5.获取返回值
 * 6.关闭线程池，不接受新的线程，未执行完毕的线程不会被关闭
 */
public class ThreadTest03 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        /*创建线程池*/
        /*线程池的作用:
        * 1.减少创建线程的时间，减少线程的资源消耗
        * 2.需要线程时候可以直接从池中取出
        * 3.减少了销毁线程浪费的资源
        * */
        /*参数是线程池的容量*/
        //ExecutorService executorService = Executors.newFixedThreadPool(2);
        /*这个线程池大小不固定，需要注意这个使用起来可能会导致线程过多引起系统耗费资源过大*/
        ExecutorService executorService = Executors.newCachedThreadPool();
        /*将自定义的Callable类的对象放入线程池*/
        Future<Integer> future = executorService.submit(new MyThread03(0));
        Future<Integer> future1 = executorService.submit(new MyThread03(1));
        /*获取结果*/
        /*判断任务是否执行完毕*/
        if(future.isDone()){
            System.out.println(future.get());
        }else{
            System.out.println("线程还没执行完毕");
        }
        if (future1.isDone()){
            System.out.println(future1.get());
        }else{
            System.out.println("线程还没执行完毕");
        }
        /*关闭线程池*/
        executorService.shutdown();
    }
}
/**
 * 计算阶乘代码
 */
class MyThread03 implements Callable<Integer> {
    Integer integer = 0;

    MyThread03(Integer integer) {
        this.integer = integer;
    }

    /*重写Call方法*/
    @Override
    public Integer call() throws Exception {
        int ans = 1;
        if (this.integer == 0) {
            return ans;
        } else if (this.integer < 0) {
            return null;
        } else {
            while (this.integer != 0) {
                ans *= this.integer;
                this.integer--;
            }
            return ans;
        }
    }
}
```
### 以上三种方法对比
1. 第一种调用各种方法就比较方便，但是java不能多继承，想要继承其他类就不行了。
2. 可以实现多种接口，也保留了继承功能，缺点:在run方法内部需要获取到线程的Thread对象才能使用Thread中的方法
3. 可以获取返回值，但是代码编写太复杂了

### 使用匿名内部类创建线程
```java
import java.util.concurrent.*;

/**
 * 使用匿名内部类创建线程
 */
public class ThreadTest04 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //Thread
        new Thread() {
            @Override
            public void run() {
                System.out.println("sdadadsasd");
            }
        }.start();

        //Runnable
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("sdadasdasdasd");
            }
        }).start();
        //Callable
        ExecutorService executorService = Executors.newCachedThreadPool();
        Future<Integer> future = executorService.submit(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                return 99;
            }
        });
        System.out.println(future.get());
        executorService.shutdown();
    }
}
```
#### 设置线程的名字的几种方式
```java
/**
 * 设置和获取线程的名字
 */
public class ThreadTest05 {
    public static void main(String[] args) {
        extracted();
        extracted1();
        extracted2();
    }

    private static void extracted2() {
        Thread thread = new Thread(){
            @Override
            public void run() {
                System.out.println("我是"+this.getName());
                System.out.println("hh");
            }
        };
        thread.start();
        /*thread.setName("haha");*/
    }

    private static void extracted1() {
        new Thread(){
            @Override
            /*
              可以在代码内设置线程名字
             */
            public void run() {
                this.setName("haHah");
                System.out.println("线程名字"+this.getName());
            }
        }.start();
    }

    private static void extracted() {
        new Thread("妈妈们"){
            @Override
            public void run() {
                System.out.println("我是:"+this.getName()+" 线程");
            }
        }.start();
        new Thread("妈妈们1"){
            @Override
            public void run() {
                System.out.println("我是:"+this.getName()+" 线程");
            }
        }.start();
    }
}
```
